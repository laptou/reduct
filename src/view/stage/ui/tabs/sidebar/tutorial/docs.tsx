/**
 * @file Component to render documentation from `resources/docs` so the user can
 * read it.
 */

import React, { useEffect, useRef, useState } from 'react';
import { createPortal } from 'react-dom';
import { connect } from 'react-redux';

import { createCreateDocs, createDeleteDocs } from '@/store/action/game';
import { GlobalState } from '@/store/state';
import { DeepReadonly } from '@/util/helper';
import { StageProjection } from '@/view/stage/projection/base';
import doc from '@resources/docs/node/binop.md';

interface DocsStoreProps {
  rootNodeIds: number[];
}

interface DocsDispatchProps {
  createDocs(key: string, script: string): void;
  deleteDocs(key: string): void;
}

type DocsProps = DocsStoreProps & DocsDispatchProps;

const DocsImpl: React.FC<DocsProps> = (props) => {
  const { html, attributes } = doc;
  const { rootNodeIds, createDocs, deleteDocs } = props;

  // we use Portals to inject React content (our stage projections) into
  // non-React content (the HTML generated by the markdown parser)
  const element = useRef<HTMLDivElement>(null);
  const [scripts, setScripts] = useState(new Map());
  
  // <code> blocks in the docs will be replaced with nodes
  // cache the scripts on first render b/c the innerText of the
  // element is replaced
  useEffect(() => {
    if (!element.current) return;

    element.current.innerHTML = html;
    
    const codeElements = element.current.getElementsByTagName('code');

    const prefix = 'binop';
    const newScripts = new Map();

    Array.from(codeElements).forEach((codeElement, index) => {
      // get the code
      const script = codeElement.innerText;
      const key = `${prefix}-${index}`;
      newScripts.set(key, {
        script,
        element: codeElement,
        index, 
      });

      // clear the element b/c using a portal won't clear it for us
      codeElement.innerHTML = '';
    });

    setScripts(newScripts);
  }, [html]);

  useEffect(() => {
    for (const [key, { script }] of scripts) {
      createDocs(key, script);
    }

    // cleanup fn
    return () => {
      for (const key of scripts.keys()) {
        deleteDocs(key); 
      }
    };
  }, [scripts, createDocs, deleteDocs]);

  return (
    <div className='docs-container'>
      <div 
        className='docs-content'
        ref={element}
      />
      {
        Array
          .from(scripts)
          .map(([key, { index, element }]) => 
            createPortal(
              <StageProjection 
                nodeId={rootNodeIds[index]} 
                key={key}
                frozen 
              />, 
              element
            )
          )
      }
    </div>
  );
};

export const Docs = connect(
  (state: DeepReadonly<GlobalState>) => ({
    rootNodeIds: [...state.game.$present.docs.values()],
  }),
  (dispatch) => ({
    createDocs(key: string, script: string) { 
      dispatch(createCreateDocs(key, script)); 
    },
    deleteDocs(key: string) { 
      dispatch(createDeleteDocs(key)); 
    },
  })
)(DocsImpl);
